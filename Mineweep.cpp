/*
题目描述:
扫雷游戏你一定玩过吧！现在给你若干个n×m的地雷阵，请你计算出每个矩阵中每个单元格相邻单元格内地雷的个数，
每个单元格最多有8个相邻的单元格。

数据规模和约定:
0< n,m< =100 

输入:
输入包含若干个矩阵，对于每个矩阵，第一行包含两个整数n和m，分别表示这个矩阵的行数和列数。
接下来n行每行包含m个字符。安全区域用‘.’表示，有地雷区域用'*'表示。当n=m=0时输入结束。 

输出:
对于第i个矩阵，首先在单独的一行里打印序号：“Field  #i:”,接下来的n行中，读入的'.'应被该位置周围的地雷数所代替。
输出的每两个矩阵必须用一个空行隔开。 

*/


#include <stdio.h>
#include<iostream>
#include<string.h>
using namespace std;


int main()
{
	int map[110][110];
	int n, m, i, j, k, t = 0;
	char z;
	int df[8][2] = { { 1, -1 }, { 1, 0 }, { 1, 1 }, { 0, -1 }, { 0, 1 }, { -1, 1 }, { -1, -1 }, { -1, 0 } }; //8个方向
	while (1)
	{
		cin >> n >> m;
		if (n == 0 && m == 0)//跳出循环条件
		{
			break;
		}
		if (t)
		{
			cout << endl;
		}
		t++;// 每两个答案之间 有一个空行 注意是之间
		memset(map, 0, sizeof(map));//初始化为 全0
		for (i = 1; i <= n; i++)//坐标从1 开始 n 结束 可以省掉处理边界
		{
			for (j = 1; j <= m; j++)
			{
				cin >> z;
				if (z == '*')//如果是雷
				{
					map[i][j] = 10;// 将是雷的地方给个标记 非雷 最多值是8 这里我取10
					for (k = 0; k < 8; k++)
					{
						map[i + df[k][0]][j + df[k][1]]++;//让周围格子自加1
					}
				}
			}
		}
		cout << "Fiel #" << t << ":" << endl;

		for (i = 1; i <= n; i++)
		{
			for (j = 1; j <= m; j++)
			{
				if (map[i][j] >= 10)
				{
					cout << "*";
				}
				else
				{
					cout << map[i][j];
				}
			}
			cout << endl;
		}
	}
	return 0;
}